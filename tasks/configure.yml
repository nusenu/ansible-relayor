---

- name: Ensure local DataDir folders exist (LOCAL)
  become: no
  file:
    path: "{{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    state: directory
    mode: 0700
  delegate_to: 127.0.0.1
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
  tags:
   - createdir

- name: Ensure all relay keys exist (LOCAL)
  become: no
  local_action: command tor --list-fingerprint --DisableNetwork 1 --orport auto --PublishServerDescriptor 0 --ExitRelay 0 --ignore-missing-torrc -f /dev/null --defaults-torrc /dev/null --Log "err stdout" --datadirectory "{{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.0.ipv4 }}_{{ item.1.orport }}"
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"

- name: Generate new Ed25519 signing keys (LOCAL)
  become: no
  local_action: command tor --keygen --SigningKeyLifetime {{ tor_signingkeylifetime_days}}\ days --ignore-missing-torrc -f /dev/null --defaults-torrc /dev/null --Log "err stdout" --datadirectory "{{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.0.ipv4 }}_{{ item.1.orport }}"
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
  tags:
   - renewkey

- name: Detect duplicate relay keys across relays (LOCAL)
  become: no
  shell: openssl sha256 -r {{ tor_offline_masterkey_dir }}/*/keys/secret_id_key {{ tor_offline_masterkey_dir }}/*/keys/ed25519_master_id_secret_key|cut -d' ' -f1|sort|uniq -d|wc -l
  delegate_to: 127.0.0.1
  run_once: true
  register: tor_dupkeycount

- name: Abort on duplicate relay keys
  fail: msg="Duplicate relay key detected! Aborting."
  run_once: true
  when: tor_dupkeycount.stdout|int(1) != 0

- name: Detect if Ed25519 master keys are on the relay
  become: yes
  stat:
    path: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/ed25519_master_id_secret_key"
  register: tor_masterkeyonline
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"

- name: Abort if Ed25519 master keys are on the relay
  fail: msg="

            Ed25519 MASTER KEY detected on the relay - it is NOT supposed to be there! Aborting."
  when: item.stat.exists == True
  with_items: "{{ tor_masterkeyonline.results }}"

# not relying on the datadir/fingerprint file is more robust
- name: Collect fingerprints for MyFamily (LOCAL)
  become: no
  shell: for key in {{ tor_offline_masterkey_dir }}/*/keys/secret_id_key; do openssl rsa -in $key -outform DER -RSAPublicKey_out 2> /dev/null| openssl sha1 -r; done|cut -d" " -f1|sort|xargs|sed -e 's/ /,/g'
  delegate_to: 127.0.0.1
  run_once: true
  register: tor_family
  tags:
   - reconfigure

- name: Ensure per-instance tor users exist
  become: yes
  user:
    name: _tor-{{ item.0.ipv4 }}_{{ item.1.orport }}
    system: yes
    shell: /bin/false
    createhome: no
    home: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}"
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"

- name: Ensure per-instance config folders exist (Debian only)
  become: yes
  file:
    path: "{{ tor_ConfDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}"
    state: directory
    mode: 0755
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
  when: ansible_pkg_mgr == 'apt'

- name: Ensure DataDir exists
  become: yes
  file:
    path: "{{ tor_DataDir }}"
    state: directory
    owner: root
    mode: 0755

- name: Ensure "keys" subfolder exists
  become: yes
  file:
    path: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}/keys"
    state: directory
    owner: "_tor-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    group: "_tor-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    mode: u=rwX,g=,o=
    recurse: yes
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"

- name: Ensure RSA key is in place (without overriding existing keys)
  become: yes
  copy:
    src: "{{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/{{ item[2] }}"
    dest: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/{{ item[2] }}"
    owner: "_tor-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    mode: 0600
    force: no
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
   - [ 'secret_id_key' ]

- name: Fetch RSA key for comparision
  become: yes
  fetch:
    src: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/{{ item[2] }}"
    dest: "{{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/{{ item[2] }}.untrustedremotekey"
    flat: yes
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
   - [ 'secret_id_key' ]

- name: Compare local vs. remote RSA key (secret_id_key)
  become: no
  local_action: shell openssl sha256 -r {{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-"{{ item.0.ipv4 }}_{{ item.1.orport }}"/keys/secret_id_key*|cut -d' ' -f1|uniq -d|wc -l
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
  register: tor_rsakey_match

- name: Abort if local and remote RSA keys do not match
  assert:
    that:
      - "item.stdout|int == 1"
    msg: "Key mismatch detected! Solution: http://bit.ly/2j6wc70 Affected instance: {{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.item.0.ipv4 }}_{{ item.item.1.orport }}/keys"
  with_items: "{{ tor_rsakey_match.results }}"

# this task is separated from the task named "Ensure RSA key is in place" because it is not run with 'force=no'
- name: Transmit new Ed25519 signing keys
  become: yes
  copy:
    src: "{{ tor_offline_masterkey_dir }}/{{ inventory_hostname }}-{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/{{ item[2] }}"
    dest: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}/keys/{{ item[2] }}"
    owner: "_tor-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    mode: 0600
    setype: tor_var_lib_t
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
   - [ 'ed25519_signing_cert', 'ed25519_signing_secret_key' ]
  tags:
   - renewkey

# This needs to be at the end to fix SELinux contexts recursively
- name: Ensure per-instance DataDir have proper permissions
  become: yes
  file:
    path: "{{ tor_DataDir }}/{{ item.0.ipv4 }}_{{ item.1.orport }}"
    state: directory
    owner: "_tor-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    group: "_tor-{{ item.0.ipv4 }}_{{ item.1.orport }}"
    mode: u=rwX,g=,o=
    recurse: yes
    setype: tor_var_lib_t
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"

- name: Ensure Tor config directory exists
  become: yes
  file:
    path: "{{ tor_ConfDir }}"
    state: directory
    owner: root
    group: "{{ tor_user }}"
    mode: 0755

- name: Ensure tor-exit-notice.html is present (if we are an exit)
  become: yes
  template:
    src: "{{ tor_exit_notice_file }}"
    dest: "{{ tor_ConfDir }}/tor-exit-notice.html"
    mode: 0444
  when: tor_ExitRelay == True and tor_ExitNoticePage == True

- name: Ensure torrc configuration file(s) are in place
  become: yes
  template:
    src: torrc
    dest: "{{ (ansible_pkg_mgr != 'apt')| ternary(tor_ConfDir ~ '/' ~ item.0.ipv4 ~ '_' ~ item.1.orport ~ '.torrc', tor_ConfDir ~ '/' ~ item.0.ipv4 ~ '_' ~ item.1.orport ~ '/torrc') }}"
    owner: root
    mode: 0644
    backup: "{{ tor_backup_torrc }}"
    validate: "tor --verify-config -f %s"
  with_nested:
   - "{{ tor_ips }}"
   - "{{ tor_ports }}"
  register: tor_instances_tmp
  loop_control:
    index_var: loop_idx
  notify:
    - Ensure Tor instances are reloaded if its torrc changed (FreeBSD)
    - Ensure Tor instances are reloaded if its torrc changed (Linux)
  tags:
   - reconfigure
